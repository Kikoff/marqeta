# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/byebug/all/byebug.rbi
#
# byebug-10.0.2
module Byebug
  def add_catchpoint(arg0); end
  def breakpoints; end
  def catchpoints; end
  def contexts; end
  def current_context; end
  def debug_load(*arg0); end
  def lock; end
  def post_mortem=(arg0); end
  def post_mortem?; end
  def raised_exception; end
  def self.add_catchpoint(arg0); end
  def self.breakpoints; end
  def self.catchpoints; end
  def self.contexts; end
  def self.current_context; end
  def self.debug_load(*arg0); end
  def self.lock; end
  def self.post_mortem=(arg0); end
  def self.post_mortem?; end
  def self.raised_exception; end
  def self.start; end
  def self.started?; end
  def self.stop; end
  def self.stoppable?; end
  def self.thread_context(arg0); end
  def self.tracing=(arg0); end
  def self.tracing?; end
  def self.unlock; end
  def self.verbose=(arg0); end
  def self.verbose?; end
  def start; end
  def started?; end
  def stop; end
  def stoppable?; end
  def thread_context(arg0); end
  def tracing=(arg0); end
  def tracing?; end
  def unlock; end
  def verbose=(arg0); end
  def verbose?; end
end
module Byebug::Helpers
end
module Byebug::Helpers::ReflectionHelper
  def commands; end
end
class Byebug::Context
  def at_breakpoint(breakpoint); end
  def at_catchpoint(exception); end
  def at_end; end
  def at_line; end
  def at_return(return_value); end
  def at_tracing; end
  def backtrace; end
  def dead?; end
  def file(*args, &block); end
  def frame; end
  def frame=(pos); end
  def frame_binding(*arg0); end
  def frame_class(*arg0); end
  def frame_file(*arg0); end
  def frame_line(*arg0); end
  def frame_method(*arg0); end
  def frame_self(*arg0); end
  def full_location; end
  def ignored?; end
  def ignored_file?(path); end
  def interrupt; end
  def line(*args, &block); end
  def location; end
  def processor; end
  def resume; end
  def self.ignored_files; end
  def self.ignored_files=(arg0); end
  def self.interface; end
  def self.interface=(arg0); end
  def self.processor; end
  def self.processor=(arg0); end
  def stack_size; end
  def step_into(*arg0); end
  def step_out(*arg0); end
  def step_over(*arg0); end
  def stop_reason; end
  def suspend; end
  def suspended?; end
  def switch; end
  def thnum; end
  def thread; end
  def tracing; end
  def tracing=(arg0); end
  extend Forwardable
  include Byebug::Helpers::FileHelper
end
class Byebug::DebugThread < Thread
  def self.inherited(arg0); end
end
class Byebug::Breakpoint
  def enabled=(arg0); end
  def enabled?; end
  def expr; end
  def expr=(arg0); end
  def hit_condition; end
  def hit_condition=(arg0); end
  def hit_count; end
  def hit_value; end
  def hit_value=(arg0); end
  def id; end
  def initialize(arg0, arg1, arg2); end
  def inspect; end
  def pos; end
  def self.add(file, line, expr = nil); end
  def self.first; end
  def self.last; end
  def self.none?; end
  def self.potential_line?(filename, lineno); end
  def self.potential_lines(filename); end
  def self.potential_lines_with_trace_points(iseq, lines); end
  def self.potential_lines_without_trace_points(iseq, lines); end
  def self.remove(id); end
  def source; end
end
module Byebug::Helpers::FileHelper
  def get_line(filename, lineno); end
  def get_lines(filename); end
  def n_lines(filename); end
  def normalize(filename); end
  def shortpath(fullpath); end
  def virtual_file?(name); end
end
class Byebug::Frame
  def _binding; end
  def _class; end
  def _method; end
  def _self; end
  def args; end
  def c_args; end
  def c_frame?; end
  def current?; end
  def deco_args; end
  def deco_block; end
  def deco_call; end
  def deco_class; end
  def deco_file; end
  def deco_method; end
  def deco_pos; end
  def file; end
  def initialize(context, pos); end
  def line; end
  def locals; end
  def mark; end
  def pos; end
  def prefix_and_default(arg_type); end
  def ruby_args; end
  def to_hash; end
  def use_short_style?(arg); end
  include Byebug::Helpers::FileHelper
end
module Byebug::Helpers::PathHelper
  def all_files; end
  def bin_file; end
  def gem_files; end
  def glob_for(dir); end
  def lib_files; end
  def root_path; end
  def test_files; end
end
module Byebug::Helpers::EvalHelper
  def allowing_other_threads; end
  def error_eval(str, binding = nil); end
  def error_msg(exception); end
  def in_new_thread; end
  def msg(exception); end
  def multiple_thread_eval(expression); end
  def safe_eval(str, binding); end
  def safe_inspect(var); end
  def safe_to_s(var); end
  def separate_thread_eval(expression); end
  def silent_eval(str, binding = nil); end
  def warning_eval(str, binding = nil); end
  def warning_msg(exception); end
end
class Byebug::CommandNotFound < NoMethodError
  def build_cmd(*args); end
  def help; end
  def initialize(input, parent = nil); end
  def name; end
end
class Byebug::CommandProcessor
  def after_repl; end
  def at_breakpoint(brkpt); end
  def at_catchpoint(exception); end
  def at_end; end
  def at_line; end
  def at_return(return_value); end
  def at_tracing; end
  def auto_cmds_for(run_level); end
  def before_repl; end
  def command_list; end
  def commands(*args, &block); end
  def confirm(*args, &block); end
  def context; end
  def errmsg(*args, &block); end
  def frame(*args, &block); end
  def initialize(context, interface = nil); end
  def interface; end
  def pr(*args, &block); end
  def prc(*args, &block); end
  def prev_line; end
  def prev_line=(arg0); end
  def printer; end
  def proceed!; end
  def process_commands; end
  def prompt; end
  def prv(*args, &block); end
  def puts(*args, &block); end
  def repl; end
  def run_auto_cmds(run_level); end
  def run_cmd(input); end
  def safely; end
  extend Forwardable
  include Byebug::Helpers::EvalHelper
end
module Byebug::Helpers::StringHelper
  def camelize(str); end
  def deindent(str, leading_spaces: nil); end
  def prettify(str); end
end
class Byebug::Setting
  def boolean?; end
  def help; end
  def initialize; end
  def integer?; end
  def self.[](name); end
  def self.[]=(name, value); end
  def self.find(shortcut); end
  def self.help_all; end
  def self.settings; end
  def to_s; end
  def to_sym; end
  def value; end
  def value=(arg0); end
end
class Pry
end
class Pry::CLI
  def self.add_option_processor(&block); end
  def self.add_options(&block); end
  def self.add_plugin_options; end
  def self.input_args; end
  def self.input_args=(arg0); end
  def self.option_processors; end
  def self.option_processors=(arg0); end
  def self.options; end
  def self.options=(arg0); end
  def self.parse_options(args = nil); end
  def self.reset; end
  def self.start(opts); end
end
class Pry::CLI::NoOptionsError < StandardError
end
class Pry::Slop::Option
  def argument?; end
  def as?; end
  def autocreated?; end
  def callback?; end
  def default?; end
  def delimiter?; end
  def limit?; end
  def match?; end
  def optional?; end
  def optional_argument?; end
  def required?; end
  def tail?; end
end
module Pry::ExtendCommandBundle
end
